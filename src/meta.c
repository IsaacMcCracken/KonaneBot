/*  
  USAGE: 
    meta.c is a metaprogram that can generate c code at compile time to 
    make our lives easier. Right now it generates bit masks for moves
    to in a static U64 array so we don't have to generate the masks at
    runtime. If need be we can expand this program to generate other files.

  COPYRIGHT:
    Copyright 2024 Isaac McCracken - All rights reserved


  NOTE: If you work on this file please add your copyright above and in the
  generated file
*/


#include <stdio.h> 
#include "types.h"

typedef struct Coord {
  I8 x;
  I8 y;
} Coord;

I8 IndexFromCoord(Coord coord) {
  return coord.x + coord.y * 8;
}

Coord CoordFromIndex(I8 index) {
  return (Coord){index % 8, index / 8};
}

// this is a program that will generate a static array of all the possible konane 
// moves.
int main() {
  // Open File
  FILE *fp = fopen("src/bitmoves.h", "w");

  // Generate Header Comment
  fprintf(fp, "/* Copyright 2024 Isaac McCracken - All rights reserved\n");
  fprintf(fp, "  This File is automatically generated from meta.c \n");
  fprintf(fp, "  This is an array of 64-bit unsigned integers that represent \n");
  fprintf(fp, "  all the possible moves given a position, the position is given\n");
  fprintf(fp, "  by the index of the array.\n");
  fprintf(fp, "  USAGE:\n    #define BITMOVES_IMPLEMENTATION // define this exactly once in your program \n");
  fprintf(fp, "    // once you've defined BITMOVES_IMPLEMENTATION include this \n");
  fprintf(fp, "    #include \"bitmoves.h\" // after defining it once you can include it as many times as you want \n");

  fprintf(fp, "*/\n\n");



  // Generate Header Guard
  fprintf(fp, "#ifndef BITMOVES_H\n#define BITMOVES_H\n\n");

  fprintf(fp, "#include \"types.h\"\n\n");


  fprintf(fp, "#define allBlack 0xaa55aa55aa55aa55llu // The starting condition of the black pieces\n");
  fprintf(fp, "#define allWhite 0x55aa55aa55aa55aallu // The starting condition of the white pieces\n\n");

  fprintf(fp, "extern const U64 bitMoves[4][64];\n\n");


  fprintf(fp, "#if defined(BITMOVES_IMPLEMENTATION)\n\n");

  /*
    if This is our position:
      0 0 0 0 0 0 0 0 
      0 0 0 0 0 0 0 0 
      0 0 0 0 0 0 0 0 
      0 0 0 0 X 0 0 0 
      0 0 0 0 0 0 0 0 
      0 0 0 0 0 0 0 0 
      0 0 0 0 0 0 0 0 
      0 0 0 0 0 0 0 0 
    then our moves would be possible moves:
      0 0 0 0 0 0 0 0  
      0 0 0 0 x 0 0 0 
      0 0 0 0 0 0 0 0 
      x 0 x 0 - 0 x 0 
      0 0 0 0 0 0 0 0 
      0 0 0 0 x 0 0 0 
      0 0 0 0 0 0 0 0 
      0 0 0 0 x 0 0 0 
  */

  
  fprintf(fp, "const U64 bitMoves[4][64] = {\n");
  for (I8 direction = 0; direction < 4; direction += 1) {
    
    fprintf(fp, "  {\n");

    for (I8 i = 0; i < 64; i++) {
      U64 result = 0;
      I8 grid[64] = { 0 };
      Coord coord = CoordFromIndex(i);


      // right
      switch (direction) {

        case Direction_right:
          for (I8 x = coord.x; x < 8; x += 1)
            grid[IndexFromCoord((Coord){x, coord.y})] = 1;
          break;

        case Direction_left:
          for (I8 x = coord.x; x >= 0; x -= 1)
            grid[IndexFromCoord((Coord){x, coord.y})] = 1;
          break;

        case Direction_up:
          for (I8 y = coord.y; y >= 0; y -= 1)
            grid[IndexFromCoord((Coord){coord.x, y})] = 1;
          break;
        
        case Direction_down:
          for (I8 y = coord.y; y < 8; y += 1)
            grid[IndexFromCoord((Coord){coord.x, y})] = 1;
          break;

        default:
          break;
      }

      // left

      // up 

      // down

      
      // now we create the number
      for (I8 i = 0; i < 64; i++) {
        result |= grid[i] * (1llu << i);
      }
      
      

      fprintf(fp, "    0x%llxllu", result);

      if (i < 63) putc(',', fp);
      putc('\n', fp);

    }

    fprintf(fp, "  }");
    if (direction < Direction_down) putc(',', fp);
    putc('\n', fp);
  }
  fprintf(fp, "};\n");
  


  fprintf(fp, "#endif // #if defined(BITMOVES_IMPLEMENTATION)\n\n");
  // Generate Header Guard end
  fprintf(fp, "#endif // BITMOVES_H");

  // Close File
  fclose(fp);
}